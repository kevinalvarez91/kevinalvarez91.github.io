<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>chud üíå</title>
<style>
:root {
	--bg-color: #fff0f3;
	--accent: #ff4d6d;
	--card-bg: #ffffff;
	--text: #1f2937;
	--muted: #6b7280;

	/* Cat dimensions */
	--cat-size: 60px;
	--track-padding: -30px; /* Negative pushes it outside */
}

* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

body {
margin: 0;
	min-height: 100vh;
display: grid;
	 place-items: center;
	 font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
background: radial-gradient(circle at 50% 0%, #ff8fa3, var(--bg-color));
color: var(--text);
overflow: hidden;
padding: 40px; /* Extra padding so cat doesn't get cut off */
}

/* --- Particle Effects (Roses/Hearts) --- */
.particle {
position: absolute;
	  pointer-events: none;
	  font-size: 24px;
	  z-index: 100;
animation: float-out 1s ease-out forwards;
}

@keyframes float-out {
	0% { transform: translate(0, 0) scale(0.5); opacity: 1; }
	100% { transform: translate(var(--tx), var(--ty)) scale(1.2) rotate(var(--rot)); opacity: 0; }
}

/* --- The Shell (Main Container) --- */
.shell {
position: relative;
width: min(500px, 85vw);
       aspect-ratio: 4/5;
       max-height: 700px;
background: var(--card-bg);
	    border-radius: 32px;
	    box-shadow: 
		    0 20px 40px -10px rgba(255, 77, 109, 0.3),
		      0 0 0 1px rgba(255, 255, 255, 0.8) inset;
padding: 30px;
display: flex;
	 flex-direction: column;
	 align-items: center;
	 justify-content: space-between;
	 z-index: 10;
}
.shell::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 32px;
  background:
    radial-gradient(circle at 20% 10%, rgba(255,255,255,0.6), transparent 50%),
    radial-gradient(circle at 80% 90%, rgba(255,100,120,0.15), transparent 50%);
  pointer-events: none;
}

/* --- Pop-up image layer (inside the white shell, behind content) --- */
.pop-layer{
  position:absolute;
  inset: 0;
  overflow: hidden;      /* hide below/edges so it feels like it comes from under */
  z-index: 5;            /* behind header/card/footer (which are z-index 10+ in your layout) */
  pointer-events:none;
  border-radius: 32px;   /* match .shell so it clips nicely */
}

/* Each popping image */
.pop-pic{
  position:absolute;
  width: 92px;
  height: 92px;
  object-fit: cover;
  border-radius: 18px;
  box-shadow: 0 18px 40px rgba(0,0,0,.18);
  opacity: 0;
  transform: translate(-50%, 0) scale(var(--s, 1)) rotate(var(--r, 0deg));
  animation: popUp 1400ms ease-out forwards;
  filter: saturate(1.05);
}

/* Pop from ‚Äúunder‚Äù the container: starts below bottom, rises, fades */
@keyframes popUp{
  0%   { opacity: 0; transform: translate(-50%, 40px)  scale(calc(var(--s, 1) * .92)) rotate(var(--r, 0deg)); }
  12%  { opacity: 1; }
  70%  { opacity: 1; }
  100% { opacity: 0; transform: translate(-50%, calc(-1 * var(--rise, 240px))) scale(var(--s, 1)) rotate(var(--r, 0deg)); }
}

/* --- The Walking Cat (Outside) --- */
.cat-track {
position: absolute;
	  /* Negative inset makes it larger than the shell */
inset: var(--track-padding); 
       pointer-events: none;
       z-index: 20; /* Sits on top of the card edge */
       border-radius: 40px; /* Slightly larger radius */
}

.cat-wrapper {
position: absolute;
width: var(--cat-size);
height: var(--cat-size);
	will-change: transform;
animation: walkPerimeter 16s linear infinite;
}

.cat {
width: 100%;
height: 100%;
filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
}
.cat.hop {
transform: translateY(-8px) scale(1.03);
}
.cat.boost {
animation: dashWiggle 220ms ease-in-out 3;
transform: scale(1.02);
}

@keyframes dashWiggle {
	0%   { transform: translateX(0) rotate(0deg) scale(1.02); }
	50%  { transform: translateX(4px) rotate(3deg) scale(1.02); }
	100% { transform: translateX(0) rotate(0deg) scale(1.02); }
}

.cat .body { animation: bounce 0.4s infinite alternate ease-in-out; transform-origin: center bottom; }
.cat .tail { animation: tailWag 1s infinite alternate ease-in-out; transform-origin: 10px 50px; }
.cat .leg-front { animation: walkLeg 0.4s infinite alternate ease-in-out; }
.cat .leg-back  { animation: walkLeg 0.4s infinite alternate-reverse ease-in-out; }

/* Walking logic for OUTSIDE:
   The cat moves from 0 to 100% of the track (which is bigger than the card).
   We use calc() to keep it strictly on the rectangular path.
 */
@keyframes walkPerimeter {
	/* Top Edge (Left to Right) */
	0%   { left: 0; top: 0; transform: rotate(0deg); }
	22%  { left: calc(100% - var(--cat-size)); top: 0; transform: rotate(0deg); }

	/* Turn Corner 1 */
	25%  { left: calc(100% - var(--cat-size)); top: 0; transform: rotate(90deg); }

	/* Right Edge (Top to Bottom) */
	47%  { left: calc(100% - var(--cat-size)); top: calc(100% - var(--cat-size)); transform: rotate(90deg); }

	/* Turn Corner 2 */
	50%  { left: calc(100% - var(--cat-size)); top: calc(100% - var(--cat-size)); transform: rotate(180deg); }

	/* Bottom Edge (Right to Left) */
	72%  { left: 0; top: calc(100% - var(--cat-size)); transform: rotate(180deg); }

	/* Turn Corner 3 */
	75%  { left: 0; top: calc(100% - var(--cat-size)); transform: rotate(270deg); }

	/* Left Edge (Bottom to Top) */
	97%  { left: 0; top: 0; transform: rotate(270deg); }

	/* Finish Loop */
	100% { left: 0; top: 0; transform: rotate(360deg); }
}

@keyframes bounce { to { transform: translateY(-3px); } }
@keyframes tailWag { from { transform: rotate(-10deg); } to { transform: rotate(15deg); } }
@keyframes walkLeg { from { transform: translateY(0); } to { transform: translateY(-4px) translateX(2px); } }


/* --- Header & Footer --- */
.header {
width: 100%;
display: flex;
	 justify-content: space-between;
	 align-items: center;
	 margin-bottom: 20px;
}
.badge {
background: #ffe4e9;
color: #d6336c;
padding: 8px 16px;
	 border-radius: 99px;
	 font-weight: 600;
	 font-size: 14px;
	 letter-spacing: 0.5px;
}
.footer {
	font-size: 14px;
color: var(--muted);
opacity: 0.8;
	 margin-top: 10px;
}

/* --- Flashcard Stage --- */
.stage {
flex: 1;
width: 100%;
display: grid;
	 place-items: center;
perspective: 1000px;
}

.card-wrap {
width: 100%;
height: 280px;
position: relative;
cursor: grab;
	transform-style: preserve-3d;
}
.card-wrap:active { cursor: grabbing; }

.flashcard {
width: 100%;
height: 100%;
position: relative;
	  transform-style: preserve-3d;
transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
	    border-radius: 24px;
	    box-shadow: 0 15px 35px rgba(0,0,0,0.1);
}

.flashcard.flipped { transform: rotateY(180deg); }

.face {
position: absolute;
inset: 0;
       backface-visibility: hidden;
       border-radius: 24px;
background: #fff;
border: 2px solid #fff0f3;
display: flex;
	 flex-direction: column;
	 justify-content: center;
	 align-items: center;
padding: 30px;
	 text-align: center;
	 user-select: none;
}

.face.front {
background: linear-gradient(135deg, #fff5f7 0%, #fff 100%);
}

.face.back {
transform: rotateY(180deg);
background: #fff;
	    border-color: #ffd6e0;
}

/* Content styling */
.label {
	font-size: 12px;
	text-transform: uppercase;
	letter-spacing: 1px;
color: #ff4d6d;
       font-weight: 700;
       margin-bottom: 12px;
}

.main-text {
	font-size: 20px;
	font-weight: 600;
	line-height: 1.5;
color: #333;
}

.hint {
	margin-top: 16px;
	font-size: 12px;
color: #9ca3af;
background: #f3f4f6;
padding: 6px 12px;
	 border-radius: 20px;
}

/* --- Progress Dots --- */
.dots {
display: flex;
gap: 6px;
     margin-top: 20px;
     justify-content: center;
}
.dot {
width: 6px;
height: 6px;
background: #ffd6e0;
	    border-radius: 50%;
transition: all 0.3s ease;
}
.dot.active {
background: #ff4d6d;
transform: scale(1.3);
}

.bg-heart {
  position: fixed;            /* important: fixed to viewport */
  left: 0;
  top: 0;
  pointer-events: none;
  opacity: 0.18;
  font-size: 34px;
  z-index: 1;                 /* behind .shell (z-index:10), above background */
  filter: blur(0.2px);
  animation: driftUp var(--dur, 18s) linear forwards;
  transform: translate(var(--x, 50vw), 110vh) scale(var(--s, 1));
}

@keyframes driftUp {
  to {
    transform: translate(calc(var(--x, 50vw) + var(--dx, 0px)), -20vh) scale(var(--s, 1));
  }
}

</style>
</head>
<body>

<div class="shell">
<div class="pop-layer" id="popLayer" aria-hidden="true"></div>
<div class="cat-track">
<div class="cat-wrapper" id="catWrapper">
<svg class="cat" viewBox="0 0 100 100">
<g class="tail">
<path d="M85 75 C 95 65, 95 40, 80 45" fill="none" stroke="#1f2937" stroke-width="6" stroke-linecap="round" />
</g>
<g class="leg-back">
<ellipse cx="35" cy="80" rx="6" ry="8" fill="#1f2937"/>
</g>
<g class="leg-back" style="transform: translateX(35px)">
<ellipse cx="35" cy="80" rx="6" ry="8" fill="#1f2937"/>
</g>
<g class="body">
<path d="M20 70 Q 20 30, 50 30 Q 80 30, 80 70 Z" fill="#1f2937"/>
<rect x="20" y="60" width="60" height="25" fill="#1f2937" rx="10"/>
<path d="M25 35 L 20 15 L 40 30 Z" fill="#1f2937"/>
<path d="M75 35 L 80 15 L 60 30 Z" fill="#1f2937"/>
<circle cx="40" cy="45" r="3" fill="#fff"/>
<circle cx="60" cy="45" r="3" fill="#fff"/>
<path d="M48 52 Q 50 54, 52 52" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/>
<ellipse cx="35" cy="50" rx="3" ry="2" fill="#ff4d6d" opacity="0.4"/>
<ellipse cx="65" cy="50" rx="3" ry="2" fill="#ff4d6d" opacity="0.4"/>
</g>
<g class="leg-front">
<ellipse cx="35" cy="82" rx="6" ry="8" fill="#1f2937"/>
</g>
<g class="leg-front" style="transform: translateX(35px)">
<ellipse cx="35" cy="82" rx="6" ry="8" fill="#1f2937"/>
</g>
</svg>
</div>
</div>

<div class="header">
<div class="badge">To <span id="herNameDisplay">Tiffany</span></div>
<div class="badge" style="background:white; border:1px solid #ffe4e9">Swipe ‚Üî</div>
</div>

<div class="stage">
<div class="card-wrap" id="cardWrap">
<div class="flashcard" id="flashcard">

<div class="face front">
<div class="label" id="counter">Reason 1</div>
<div class="main-text">I HATE talking to you because...</div>
<div class="hint">Tap to flip</div>
</div>

<div class="face back">
<div class="label">‚ú®</div>
<div class="main-text" id="reasonText">...</div>
<div class="hint">Swipe for next</div>
</div>

</div>
</div>
<div class="dots" id="dots"></div>
</div>

<div class="footer">from <span id="yourNameDisplay">kevin</span></div>
</div>

<script>
// --- Configuration ---
const config = {
	herName: "chud #1",
	 yourName: "chud #2",
	 reasons: [
	 "your the funniest person alive i guess",
	 "you care (i think)",
	 "your a closeted chud",
	 "talking to you kinda makes my day sometimes", 
	 "your annoying and easy to talk to but mainly annoying",
	 "you say dumb stuff in a good way all the time",
	 "your cooler than you actually think you are (don't let this go to ur head)",
	 "you make boring days less boring",
	 "your highly entertaining ",
	 "your annoying"
	 ]
};

// --- State ---
let currentIndex = 0;

// --- Elements ---
const els = {
cardWrap: document.getElementById('cardWrap'),
	  card: document.getElementById('flashcard'),
	  reasonText: document.getElementById('reasonText'),
	  counter: document.getElementById('counter'),
	  dots: document.getElementById('dots'),
	  herName: document.getElementById('herNameDisplay'),
	  yourName: document.getElementById('yourNameDisplay')
};

// --- Init ---
els.herName.textContent = config.herName;
els.yourName.textContent = config.yourName;
renderDots();
updateCard();

// --- Pop-up pictures (1 per second, random delay 0-1000ms) ---
const popLayer = document.getElementById('popLayer');

const popPics = [
  "burglar.jpeg",
  "crying1.jpeg",
  "burittio.jpeg",
  "crying2.jpeg",
  "eyes.jpeg", 
  "crying1.jpeg"
];

const ambientHearts = ["üíó","üíñ","üíï","üíù","‚ú®","üå∏"];

function spawnBgHeart() {
  const h = document.createElement("div");
  h.className = "bg-heart";
  h.textContent = ambientHearts[Math.floor(Math.random() * ambientHearts.length)];

  // Random horizontal position + slight sideways drift
  const x = Math.random() * 100;               // vw
  const dx = (Math.random() * 120 - 60);       // px
  const s = 0.6 + Math.random() * 1.0;         // scale
  const dur = 14 + Math.random() * 14;         // seconds

  h.style.setProperty("--x", `${x}vw`);
  h.style.setProperty("--dx", `${dx}px`);
  h.style.setProperty("--s", s.toFixed(2));
  h.style.setProperty("--dur", `${dur.toFixed(1)}s`);

  document.body.appendChild(h);

  h.addEventListener("animationend", () => h.remove());
}

// spawn a few immediately so you SEE it working
for (let i = 0; i < 6; i++) setTimeout(spawnBgHeart, i * 400);

// then keep spawning
setInterval(spawnBgHeart, 1200);

function spawnPopPic() {
  const img = document.createElement('img');
  img.className = 'pop-pic';

  const file = popPics[Math.floor(Math.random() * popPics.length)];
  img.src = `./${file}`;
  img.alt = "";

  img.onerror = () => {
    console.warn("Image failed to load:", img.src);
    img.remove();
  };

  // random position across the shell
  const xPct = 10 + Math.random() * 80; // 10% .. 90%
  img.style.left = `${xPct}%`;

  // start just below bottom edge
  img.style.bottom = `-40px`;

  // random rise height, rotation, scale
  const rise = 180 + Math.random() * 160;     // 180..340px
  const rot  = -14 + Math.random() * 28;      // -14..+14 deg
  const sc   = 0.9 + Math.random() * 0.35;    // 0.9..1.25

  img.style.setProperty('--rise', `${rise}px`);
  img.style.setProperty('--r', `${rot}deg`);
  img.style.setProperty('--s', sc.toFixed(2));

  popLayer.appendChild(img);
  img.addEventListener('animationend', () => img.remove());
}

// Exactly 1 picture per second, with a random delay inside that second.
setInterval(() => {
  const delay = Math.floor(Math.random() * 1000); // 0..999ms
  setTimeout(spawnPopPic, delay);
}, 1000);


// --- Flip sound (same directory) ---
const flipSound = new Audio('./yippee-tbh.mp3');
flipSound.preload = 'auto';
flipSound.volume = 0.7;

let audioPrimed = false;
function primeAudio() {
	if (audioPrimed) return;
	audioPrimed = true;
	// Some browsers require a user gesture before audio can play
	flipSound.play().then(() => {
			flipSound.pause();
			flipSound.currentTime = 0;
			}).catch(() => {
				// ignore if it fails; will try again on next gesture
				audioPrimed = false;
				});
}

function playFlipSound() {
	// restart from beginning every flip
	try {
		flipSound.currentTime = 0;
		flipSound.play();
	} catch {}
}

// Prime audio on first user interaction anywhere
window.addEventListener('pointerdown', primeAudio, { once: true });
window.addEventListener('keydown', primeAudio, { once: true });

const catEl = document.querySelector('.cat'); 
let hopTimer = null; 
let boostTimer = null; 

function catBoost() {
	// restart the wiggle animation by removing/adding class
	clearTimeout(boostTimer);
	catEl.classList.remove('boost');
	void catEl.offsetWidth; // force reflow to restart keyframes
	catEl.classList.add('boost');
	boostTimer = setTimeout(() => catEl.classList.remove('boost'), 700);
}

function catHop() {
	clearTimeout(hopTimer);
	catEl.classList.add('hop');
	hopTimer = setTimeout(() => catEl.classList.remove('hop'), 180);
}

// --- Core Functions ---
function renderDots() {
	els.dots.innerHTML = '';
	config.reasons.forEach((_, i) => {
			const d = document.createElement('div');
			d.className = `dot ${i === currentIndex ? 'active' : ''}`;
			els.dots.appendChild(d);
			});
}

function updateCard() {
	els.counter.textContent = `Reason ${currentIndex + 1}`;
	els.reasonText.textContent = config.reasons[currentIndex];

	document.querySelectorAll('.dot').forEach((d, i) => {
			d.classList.toggle('active', i === currentIndex);
			});

	els.card.classList.remove('flipped');
}

function spawnParticles(type, x, y) {
	const count = type === 'rose' ? 8 : 12;
	const emojis = type === 'rose' ? ['üåπ', 'üå∏', 'üå∫'] : ['‚ú®', 'üíñ', 'üíù', 'üíï'];

	for (let i = 0; i < count; i++) {
		const el = document.createElement('div');
		el.className = 'particle';
		el.innerText = emojis[Math.floor(Math.random() * emojis.length)];

		// Random spread
		const angle = Math.random() * Math.PI * 2;
		const velocity = 100 + Math.random() * 150;
		const tx = Math.cos(angle) * velocity;
		const ty = Math.sin(angle) * velocity;
		const rot = Math.random() * 360;

		el.style.left = x + 'px';
		el.style.top = y + 'px';
		el.style.setProperty('--tx', `${tx}px`);
		el.style.setProperty('--ty', `${ty}px`);
		el.style.setProperty('--rot', `${rot}deg`);

		document.body.appendChild(el);

		// Cleanup
		setTimeout(() => el.remove(), 1000);
	}
}

function nextCard() {
	currentIndex = (currentIndex + 1) % config.reasons.length;
	animateSwap('left');
}

function prevCard() {
	currentIndex = (currentIndex - 1 + config.reasons.length) % config.reasons.length;
	animateSwap('right');
}

function animateSwap(dir) {
	// Trigger Roses
	catBoost(); 
	const rect = els.card.getBoundingClientRect();
	const originX = dir === 'left' ? rect.right : rect.left;
	const originY = rect.top + rect.height / 2;
	spawnParticles('rose', originX, originY);

	const xOff = dir === 'left' ? -20 : 20;
	els.card.style.transition = "transform 0.2s, opacity 0.2s";
	els.card.style.transform = `translateX(${xOff}px) scale(0.9)`;
	els.card.style.opacity = '0';

	setTimeout(() => {
			updateCard();
			els.card.style.transition = 'none';
			els.card.style.transform = `translateX(${dir === 'left' ? 20 : -20}px) scale(0.9)`;

			requestAnimationFrame(() => {
					els.card.style.transition = "transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s";
					els.card.style.opacity = '1';
					els.card.style.transform = "translateX(0) scale(1)";
					});
			}, 200);
}

// --- Input Handling ---

// Tap to Flip
els.cardWrap.addEventListener('click', (e) => {
		if (isDragging) return;
		els.card.classList.toggle('flipped');
        playFlipSound(); 

		// Trigger Hearts only if flipping to back
		if (els.card.classList.contains('flipped')) {
		catHop(); 
		spawnParticles('heart', e.clientX, e.clientY);
		}
		});

// Drag / Swipe Logic
let startX = 0;
let isDragging = false;
let isPressed = false;

const startDrag = (x) => {
	isPressed = true;
	isDragging = false;
	startX = x;
	els.card.style.transition = 'none';
};

const moveDrag = (x) => {
	if (!isPressed) return;
	const dx = x - startX;
	if (Math.abs(dx) > 5) isDragging = true;

	const rot = dx * 0.05;
	els.card.style.transform = `translateX(${dx}px) rotate(${rot}deg)` + 
		(els.card.classList.contains('flipped') ? ' rotateY(180deg)' : '');
};

const endDrag = (x) => {
	if (!isPressed) return;
	isPressed = false;

	const dx = x - startX;
	const threshold = 100;

	if (Math.abs(dx) > threshold) {
		if (dx > 0) prevCard();
		else nextCard();
	} else {
		els.card.style.transition = "transform 0.4s ease";
		els.card.style.transform = els.card.classList.contains('flipped') ? 'rotateY(180deg)' : '';
	}
};

// Touch Events
els.cardWrap.addEventListener('touchstart', e => startDrag(e.touches[0].clientX));
els.cardWrap.addEventListener('touchmove', e => moveDrag(e.touches[0].clientX));
els.cardWrap.addEventListener('touchend', e => endDrag(e.changedTouches[0].clientX));

// Mouse Events
els.cardWrap.addEventListener('mousedown', e => { e.preventDefault(); startDrag(e.clientX); });
window.addEventListener('mousemove', e => moveDrag(e.clientX));
window.addEventListener('mouseup', e => endDrag(e.clientX));

// Keyboard Support
window.addEventListener('keydown', e => {
		const rect = els.card.getBoundingClientRect();
		if (e.key === 'ArrowRight') nextCard();
		if (e.key === 'ArrowLeft') prevCard();
		if (e.key === ' ' || e.key === 'Enter') {
		els.card.classList.toggle('flipped');
        playFlipSound(); 
		if (els.card.classList.contains('flipped')) {
		spawnParticles('heart', rect.left + rect.width/2, rect.top + rect.height/2);
		}
		}
		});

</script>
</body>
</html>
